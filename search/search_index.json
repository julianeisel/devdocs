{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Proof of Concept</p> <p> This is a proof of concept and most pages here are dummies. Check the asset system documentation for a more fleshed out part to show/test a new approach structure technical documentation.</p>"},{"location":"#blender-developer-documentation","title":"Blender Developer Documentation","text":"<p>If you want to understand how Blender looks like inside (and maybe do a change or two), you found the right place. Choose an area to learn more about or start with the developer handbook.</p> <ul> <li> <p> Blender Developer Handbook</p> <p>Important general information for beginners and experienced coders alike. If you are new to Blender development, this is the place to start your journey. Includes build instructions, guidelines, tools and basic architectural information.</p> </li> </ul>"},{"location":"#dive-deeper","title":"Dive Deeper","text":"<ul> <li> <p>Core Data Management</p> <p>Data-blocks, the main database, .blend files, DNA, RNA, undo/redo.</p> </li> <li> <p>Asset System</p> <p>Functionality for assets (entities packaged for sharing/reuse) as a first class citizen in Blender.</p> </li> <li> <p>Animation</p> <p>Core scene animation system (animation data, drivers, etc), time based dependency evaluation (dependency graph), animation editors, interactive animation tools.</p> </li> <li> <p>User Interface</p> <p>Widgets, windowing system, event handling, accessability.</p> </li> <li> <p>Rendering</p> </li> </ul> <ul> <li> <p> Contribute to this Documentation</p> <p>You want to help improve the Blender developer documentation? Great! Here you find information on how to build the documentation, change it and get the changes online.</p> </li> <li> <p> Give Feedback</p> <p>Something is unclear or could be improved? Create a feedback ticket here.</p> </li> </ul>"},{"location":"animation/","title":"Animation","text":"<p>Dummy page.</p>"},{"location":"asset_system/","title":"Asset System","text":"<p>The asset system brings a native understanding of assets (entities packaged for sharing/reuse) to Blender's core design, and enriches it with a number of features for great asset based workflows.</p> <p>For example it includes: The asset browser, asset shelfs, asset libraries, asset library loading, asset catalogs, asset metadata, etc.</p> <p>The backend implements all the core types and functionality, which various parts Blender can access. The design is user experience driven, and as such, the backend very much serves the user interface. They work in close collaboration to provide an experience that makes assets feel like first-class citizens in Blender.</p> <p>Note</p> <p> The asset system is still in early development so expect this documentation to receive regular updates. In various places, it will refer to designs that are not there yet (at least not in the <code>master</code> branch), partially there or just temporary. This will be clearly indicated.</p>"},{"location":"asset_system/FAQ/","title":"Asset System FAQ","text":"<p>Common questions regarding the asset system, and how to use it on the technical side. This is not meant as artist level documentation, such questions should be answered in the user manual.</p>"},{"location":"asset_system/FAQ/#how-to-port-my-asset-add-on-to-the-asset-browsersystem","title":"How to port my asset add-on to the Asset Browser/System?","text":"<p>One of the main goals of the asset project is to bring a standardized user and developer interface for a consistent asset browsing experience. There are numerous add-ons that implement their own asset management/browsing UI. Via the asset system, everybody should be able to use the native Asset Browser as the main place to access assets instead. This includes assets stored on the web, with on-demand downloading.</p> <p>The asset system is still in early stages of development, and the Python API is only in the initial planning phases. That means, although this is a main goal of the overall project, we are by far not there yet. Blender is currently only able to recognize data-blocks as assets stored on the user's hard drive. This may already be enough for your use-case. Users or an add-on can download .blend files containing assets, and the <code>blender-assets.cats.txt</code> to some directory. This directory can then be registered as an asset library. There is also a way to display assets that are not stored on the hard drive. For that an add-on can generate .blend files with dummy data-block assets (with metadata and previews). After dragged into the scene, the add-on can download the actual asset and replace the dummy one with it. Many existing asset add-ons already worked this way, so it should be easy to move towards the Asset Browser. This is a workaround for until there is a proper asset system API for add-ons to use.</p>"},{"location":"asset_system/FAQ/#python-api","title":"Python API","text":"<p>At this point, there is no proper Python API for the asset system yet, it is still in the planning. There are still ways to achieve commonly requested functionality through other parts of the Python API however.</p>"},{"location":"asset_system/FAQ/#how-do-i-load-custom-previews","title":"How do I load custom previews?","text":"<p>There is no simple <code>asset.load_custom_preview(filepath)</code> method or similar available. But there are still two ways to do the job:</p> <ul> <li> <p><code>bpy.ops.ed.lib_id_load_custom_preview()</code>: Attempts to load an image file from a <code>filepath</code> property (opens a File Browser if not set) to the active ID set in context. <pre><code>override = context.copy()\n# Set context \"id\" member to some ID, e.g. a material.\noverride[\"id\"] = my_material\nwith context.temp_override(**override):\n   bpy.ops.ed.lib_id_load_custom_preview(filepath=\"path/to/image.png\")\n</code></pre>   Or to call the operator from a button: <pre><code># Set layout context \"id\" member to some ID, e.g. a material.\nlayout.context_pointer_set(\"id\", my_material)\nprops = layout.operator(\"ed.lib_id_load_custom_preview\")\nprops.filepath = \"path/to/image.png\"\n</code></pre></p> </li> <li> <p><code>bpy.types.ID.preview</code>: ID assets (and currently all assets have to be IDs) share the ID's preview image. So the preview can be manipulated via the <code>bpy.types.ImagePreview</code> API. This allows loading a custom buffer into the preview.For example: <pre><code>buffer = ... # Some 32-bit RGBA buffer\n* Overwrite buffer of a material's preview image.\n# Important: Assumes the image size in the buffer matches `my_material.preview.image_size`!\nmy_material.preview.image_pixels = buffer\n</code></pre></p> </li> </ul>"},{"location":"asset_system/backend/asset_catalogs/","title":"Asset Catalogs","text":"<p>An asset can be assigned a catalog. Similar to files on disk, where a file can only exist in a single directory at a time (ignoring hard-links), an asset can only be associated with a single catalog at a time.</p> <p>These catalogs are independent of the on-disk organisation of asset library files. This means that assets can be freely moved between blend files while staying in the same catalog, and vice versa.</p> <p>Introduced in Blender 3.0.</p>"},{"location":"asset_system/backend/asset_catalogs/#components-of-a-catalog","title":"Components of a Catalog","text":"<p>Each catalog consists of a ''catalog path'', a ''UUID'', and a ''simple name''.</p>"},{"location":"asset_system/backend/asset_catalogs/#catalog-path","title":"Catalog Path","text":"<p>The path of a catalog determines where in the catalog hierarchy the catalog is shown. Examples are <code>Characters/Ellie/Poses/Hand</code> or <code>Kitbash/City/Skyscrapers</code>.</p> <p>Multiple catalogs can have the same path; in other words, multiple UUIDs can map to the same path. This is likely to happen with generic paths like <code>Materials/Metal</code> when combining assets from various sources. These catalogs are unified and shown as one catalog in the user interface.</p>"},{"location":"asset_system/backend/asset_catalogs/#uuid","title":"UUID","text":"<p>Each catalog has a UUID. This is what is stored in the asset, and what determines the \"identity\" of the catalog. As a result, a catalog can be renamed or moved around (i.e. you can change its path), and all assets that are contained in it will move along with it. This only requires a change to the catalog itself, and not to any asset blend file.</p> <p>When creating a new catalog, Blender assigns it a random UUID. However, any valid, non-nil UUID can be used for catalogs. An asset can be assigned to the nil UUID, which means it's not contained in any catalog.</p>"},{"location":"asset_system/backend/asset_catalogs/#simple-name","title":"Simple Name","text":"<p>Each catalog has an optional ''simple name''. This name is stored along with the UUID in each asset. The purpose is to make it possible for humans to recognise the catalog the asset was assigned to, even when the ''catalog definition file'' (see below) is lost.</p>"},{"location":"asset_system/backend/asset_catalogs/#catalog-definition-files","title":"Catalog Definition Files","text":"<p>Asset catalogs are stored in Catalog Definition Files (CDFs). Currently, each asset library has one CDF, <code>blender_assets.cats.txt</code>.</p>"},{"location":"asset_system/backend/asset_catalogs/#format","title":"Format","text":"<p>Catalog Definition Files (CDFs) are relatively simple text files, encoded in UTF-8.</p> <p>Each CDF consists of a version indicator, and a line of text per catalog.</p> <p>Each catalog line is colon-separated, of the form <code>{UUID}:{path}:{simple name}</code>.</p> <p>Multiple catalogs can have the ''same path'', as described above. If there are multiple catalog definitions with the ''same UUID'', the first one \"wins\" and the rest is ignored.</p>"},{"location":"asset_system/backend/asset_catalogs/#examples","title":"Examples","text":"<p>For example, this is a valid catalog definition file: <pre><code># This is an Asset Catalog Definition file for Blender.\n#\n# Empty lines and lines starting with `#` will be ignored.\n# The first non-ignored line should be the version indicator.\n# Subsequent lines are of the format \"CATALOG_UUID:catalog/path/for/assets:simple catalog name\"\n\nVERSION 1\n\ncd66bf52-58f4-45cb-a4e2-dc0e0ee8f3fe:/character/Elly/poselib:POSES_ELLY\n\n  4eb44ec6-3424-405b-9782-ca006953e799:character/Elly/poselib/white space:POSES_ELLY_WHITESPACE\n\nee9c7b60-02f1-4058-bed6-539b8d2a6d34:/character/Elly/poselib/:POSES_ELLY_TRAILING_SLASH\n\nb63ed357-2511-4b96-8728-1b5a7093824c:character/Ru\u017eena/poselib:Ru\u017eena pose library\nfb698f2e-9e2b-4146-a539-3af292d44899:character/Ru\u017eena/poselib/hand:Ru\u017eena hands\ndcdee4df-926e-4d72-b995-33106983bb9a:character/Ru\u017eena/poselib/face:Ru\u017eena face\n\n313ea471-7c81-4de6-af81-fb04c3535d0e:catalog/without/simple/name\n</code></pre></p> <p>After reading it, Blender will reformat it to look like this: <pre><code># This is an Asset Catalog Definition file for Blender.\n#\n# Empty lines and lines starting with `#` will be ignored.\n# The first non-ignored line should be the version indicator.\n# Subsequent lines are of the format \"CATALOG_UUID:catalog/path/for/assets:simple catalog name\"\n\nVERSION 1\n\n313ea471-7c81-4de6-af81-fb04c3535d0e:catalog/without/simple/name:\nee9c7b60-02f1-4058-bed6-539b8d2a6d34:character/Elly/poselib:POSES_ELLY_TRAILING_SLASH\ncd66bf52-58f4-45cb-a4e2-dc0e0ee8f3fe:character/Elly/poselib:POSES_ELLY\n4eb44ec6-3424-405b-9782-ca006953e799:character/Elly/poselib/white space:POSES_ELLY_WHITESPACE\nb63ed357-2511-4b96-8728-1b5a7093824c:character/Ru\u017eena/poselib:Ru\u017eena pose library\ndcdee4df-926e-4d72-b995-33106983bb9a:character/Ru\u017eena/poselib/face:Ru\u017eena face\nfb698f2e-9e2b-4146-a539-3af292d44899:character/Ru\u017eena/poselib/hand:Ru\u017eena hands\n</code></pre></p>"},{"location":"asset_system/backend/asset_catalogs/#valid-catalog-paths","title":"Valid Catalog Paths","text":"<p>Catalog paths in the catalog definition files have to follow the following rules:</p> <ul> <li>All paths are absolute, so there is no difference between <code>/a/b</code> and <code>a/b</code>.</li> <li>Only <code>/</code> as separator (no <code>\\</code>; think less filesystem path and more URL).</li> <li>Not empty (it's required for a valid catalog).</li> <li>No empty components (so not <code>a//b</code>; <code>a/b</code> is fine).</li> <li>Invalid characters: <code>:</code>, <code>\\</code>.</li> <li>Paths are always interpreted as UTF-8.</li> </ul> <p>When the asset system reads the catalog definitions, or when the paths where changed in another way (e.g. by renaming catalogs in the UI), the paths are \"normalized\" by doing the following:</p> <ul> <li>Remove any leading or trailing <code>/</code></li> <li><code>/</code> characters are escaped by replacing them with <code>\\/</code></li> </ul> <p>The asset system code only uses this \"normalized\" version of the path.</p>"},{"location":"asset_system/backend/asset_catalogs/#writing-to-disk","title":"Writing to Disk","text":"<p>Catalogs are written to disk when the blend file is saved (this is still under consideration and can change). At this moment only a single catalog definition file (CDF) per asset library is supported; CDFs are always named <code>blender_assets.cats.txt</code>.</p> <p>The location of the CDF is chosen as follows. The first rule that describes the situation \"wins\" and determines the location:</p> <ol> <li>If the catalogs were loaded from disk (for example by selecting an existing library with existing catalogs in the asset browser), any changes/additions are written to the same file.</li> <li>If the blend file is saved in a known asset library (i.e. configured in the preferences), any changes/additions are written to the top-level directory of that asset library.</li> <li>Otherwise the CDF is saved in the same directory as the blend file.</li> </ol>"},{"location":"asset_system/backend/asset_index/","title":"Asset Indexing","text":"<p>Asset indexing provides an optimized way to load asset representations into the asset system. With asset indexing, users have to spend significantly less time waiting for asset libraries to be loaded and ready to use.</p> <p>Information about the asset like its asset meta-data (link), name and data-block type is extracted from asset files and stored in asset index files. Asset indexing can observe the content of asset libraries to perform minimal updates to the asset index files.</p> <p>The asset index files are stored in a local cache of the user's operating system.</p>"},{"location":"asset_system/backend/asset_index/#glossary","title":"Glossary","text":"<p>Glossary used within the scope of this page.</p> Asset Data-blocks that have been tagged by users to be an asset. Asset File Blend file which is located inside an asset library. Asset Library See Asset Library (Wiki). Asset Index File JSON file containing information limited to selecting and browsing about assets contained inside a single asset file. Asset Catalog See Asset Catalos. Asset representation See Asset Representation. File Browser <p>Editor in blender used for navigating file system and finding data-blocks in blend files. Used for linking, appending, file open, import, save and asset browsing functionalities.</p> Data-block See ID Datablocks (Wiki)."},{"location":"asset_system/backend/asset_index/#logical-overview","title":"Logical Overview","text":""},{"location":"asset_system/backend/asset_index/#problem-statement","title":"Problem statement","text":"<p>Assets are stored in a blend file as part of an asset library. In order to browse through the assets of an asset library Blender has to parse each asset file in order to know which data-blocks have been tagged as assets. Doing this each time when browsing assets and having large asset libraries extracting the assets can take a long time.</p> <ul> <li>Blender loads asset files sequentially in a background thread, which is a slow operation.</li> <li>Asset libraries can be located on network shares and version controlled repositories.</li> <li>Asset libraries can have a large number of files.</li> <li>Asset files can be large is size.</li> <li>Asset files can be compressed.</li> <li>Asset files may not actually contain assets.</li> </ul>"},{"location":"asset_system/backend/asset_index/#solution","title":"Solution","text":"<p>To reduce the time needed to browse asset libraries we want to extract the assets representation from the asset files and store them in the asset index. When the asset file isn\u2019t changed, the asset index file would contain the required information needed to be able to reconstruct the [https://wiki.blender.org/wiki/Source/Architecture/Asset_System/Back_End#Asset_Representation asset representation].</p>"},{"location":"asset_system/backend/asset_index/#requirements","title":"Requirements","text":"<p>Each asset file has an asset index file.</p> <p>Each asset file has an asset index file even when the asset file has no assets. The reason is that asset files can be part of an asset library without containing assets. For example when an asset file contains materials which are linked from assets inside a different asset file, but those materials are not assets themselves. If there was no index, the file would be parsed every time.</p> <p>Icons of assets are not part of the asset index file.</p> <p>Compared to the rest of the asset representation, icons can use a lot of disk space. Blender already has an icon manager that utilizes the OS to store and cache icons. Therefore we chose not to include the icon inside the asset representation.</p> <p>Empty asset files can be detected without opening the asset index file.</p> <p>Opening, reading and parsing asset index files has latency. Detecting if there are actually asset representations stored inside the asset index file after parsing isn\u2019t efficient. By checking the file size on disk, the asset indexer can already check if there are any asset representations inside the asset index file, removing the need for opening, reading and parsing the file.</p> <p>Info</p> <p> The asset index is implemented as a file indexer (<code>FileIndexerType</code>). Browsing assets shares logic with the file browser editor. File browser uses file indexers to read data from folders on a file-system, but also to list data-blocks located inside blend-files or data-blocks from asset libraries.</p> <p>The usage of the File browser for asset listing and <code>FileIndexerType</code> is planned to be refactored. (See {{Phab|T999999}})</p>"},{"location":"asset_system/backend/asset_index/#asset-library-loading-process","title":"Asset library loading process","text":"<p>The sequence diagram shown above describes an overview control flow of the asset indexer. When the asset browser needs to know the asset representations that are inside an asset library it uses a <code>FileList</code>. The file list walks over the file inside the asset library and when an asset file is detected it invokes <code>read_index</code> on the <code>AssetFileIndexer</code>. <code>read_index</code> returns if the found asset representations (<code>EntriesLoaded</code>) or that the asset index file need to be updated for the given asset file.</p> <p>If the asset file index requires an update, the file list extracts the asset representations from the asset file and invokes <code>update_index</code>. Update entries would create update or create the asset index file with the given asset representations.</p>"},{"location":"asset_system/backend/asset_index/#asset-index","title":"Asset Index","text":"<p>When browsing assets, asset indexes are created when they don\u2019t exist or are out of date. The asset browser does not access asset files directly, but uses asset indexes.</p>"},{"location":"asset_system/backend/asset_index/#storage","title":"Storage","text":"<p>The asset index files are stored in the [https://docs.blender.org/manual/en/latest/advanced/blender_directory_layout.html#local-cache-directory local cache directory]. Within the local cache directory the indexes are stores using the following pattern: <code>/asset-library-indices/&lt;asset-library-hash&gt;/&lt;asset-index-hash&gt;_&lt;asset_file&gt;.index.json</code>.</p> <code>asset-library-hash</code> Hash of the absolute file path of the asset library. <code>asset-index-hash</code> Hash of the absolute file path of the asset file. <code>asset_file</code> Filename of the asset file. Not used by Blender, but is added for discoverability convenience."},{"location":"asset_system/backend/asset_index/#content","title":"Content","text":"<pre><code>{\n\"version\": &lt;file version number&gt;,\n\"entries\": [{\n\"name\": \"&lt;asset name&gt;\",\n\"catalog_id\": \"&lt;catalog_id&gt;\",\n\"catalog_name\": \"&lt;catalog_name&gt;\",\n\"description\": \"&lt;description&gt;\",\n\"author\": \"&lt;author&gt;\",\n\"tags\": [\"&lt;tag&gt;\"],\n\"properties\": [..]\n}]\n}\n</code></pre> <code>version</code> the version of the asset index file. It is used to identify the structure of the content. Asset indexes with a different version than used by Blender would be regenerated. Blender 3.1-3.4 expect version attribute to be <code>1</code>.). Later versions might require to change it. <code>entries</code> list of assets in the asset file related to the asset index. <code>entries[].name</code> ID name of the asset, including its ID type prefix. (<code>OBSuzanne</code>). <code>entries[].catalog_id</code> UUID of the catalog associated with the asset. <code>entries[].catalog_name</code> Name of the catalog associated with the asset. <code>entries[].description</code> Human readable description of the asset. <code>entries[].author</code> Information about the author of the asset. <code>entries[].tags</code> List of tags associated with this asset. <code>entries[].properties</code> List of ID Properties associated with this asset."},{"location":"asset_system/backend/asset_index/#performance","title":"Performance","text":"<p>Performance is optimized for reading and parsing asset indexes.</p> <ul> <li>Asset libraries can have blend files that doesn\u2019t contain any assets. To reduce opening and parsing an asset index that doesn\u2019t contain any entries the size on disk of the asset index is checked. Asset indexes smaller than <code>MIN_FILE_SIZE_WITH_ENTRIES</code> would not be parsed and assumed to contain no entries.</li> <li>Asset indexes older than asset files are assumed to be out of date and should be regenerated. This can be determined without opening the asset index.</li> <li>Asset indexes of asset files on network shares are stored on your local system to reduce latency. Although this could depends on how your OS has been configured.</li> </ul>"},{"location":"asset_system/backend/asset_index/#future-expected-changes","title":"Future expected changes","text":"<p>This section will contain a table with planned tasks and remark how it would change the asset indexing.</p> <p>To be added</p>"},{"location":"asset_system/backend/asset_index/#references","title":"References","text":"<ul> <li>Technical overview of asset catalogs: <code>https://wiki.blender.org/wiki/Source/Architecture/Asset_System/Catalogs</code>.</li> <li>The main source code is located at <code>source/blender/editors/asset/intern/asset_indexer.cc</code> and <code>source/blender/editors/asset/ED_asset_indexer.h</code>.</li> <li>End user documentation about assets library system <code>https://docs.blender.org/manual/en/latest/files/asset_libraries/introduction.html</code>, <code>https://docs.blender.org/manual/en/latest/files/asset_libraries/catalogs.html</code></li> </ul>"},{"location":"asset_system/backend/asset_list_api/","title":"Asset List API","text":"<p>The asset list API is a temporary design to provide global access to asset libraries, the contained assets and catalogs.</p> <p>The implementation uses the file browser backend still. As such it's just an asset-centric abstraction for the file browser backend.</p>"},{"location":"asset_system/fundamentals/","title":"Important Concepts","text":""},{"location":"asset_system/fundamentals/#what-is-an-asset-anyway","title":"What is an Asset anyway?","text":"<p>The Blender reference manual gives a user level answer to this question. As far as the asset system design goes, assets are arbitrary entities that are packaged for organized sharing/reuse.</p> <p>The term entity is used here, because the design is meant to support assets that are not Blender data-blocks (also called IDs or ID Datablocks on a technical level), even if the current implementation is limited to that. In future it should be possible to let the asset system deal with any data as assets, like files on disk, USD prims, SQL data-base entities, data fetched from the web, etc. This only works because the asset system doesn't deal with the actual underlying entity itself (the object, the material, the brush, etc.). It only deals with the package of the entity.</p>"},{"location":"asset_system/fundamentals/#asset-representation","title":"Asset Representation","text":"<p>If assets are packaged entities, what does the package look like? An asset representation is the package for an asset, which enables the asset system to work with it. When loading an asset library, an asset representation is created for each detected asset and put into the asset library storage.</p> <p>Note that an asset representation is just the package itself, and usually doesn't contain the actual entity. It contains information on how/where to find the entity, so that the asset can be loaded when the user asks for it.</p>"},{"location":"asset_system/fundamentals/#a-new-core-non-main-database","title":"A New Core (non-<code>Main</code>) Database","text":"<p>At Blender's core design, there is the <code>Main</code> database to store the data-blocks for the current file, accessible for all of Blender. Through the storage of the asset libraries, the asset system effectively provides another global data-base, but for entities that may not be part of the current file.</p> <p>Unlike <code>Main</code>, the asset library storage is not meant to be written to files (although an asset index is written to improve loading speeds).</p>"},{"location":"asset_system/fundamentals/architectural_overview/","title":"Architectural Overview","text":"<p>The entire asset system can be stripped down to it's main components:</p> <pre><code>stateDiagram-v2\n  direction TB\n\n  asset_system_backend: Asset System Backend\n\n  asset_system_backend --&gt; UI\n  BPY --&gt; asset_system_backend\n  asset_system_backend --&gt; BPY\n\n  state asset_system_backend {\n    direction LR\n\n    asset_libraries: Asset Libraries\n    asset_catalogs: Asset Catalogs\n    asset_representations: Asset Representations\n\n    asset_libraries --&gt; asset_catalogs\n    asset_libraries --&gt; asset_representations\n  }\n\n  state UI {\n    direction RL\n\n    asset_browser: Asset Browsers\n    asset_shelf: Asset Shelfs\n    asset_views: Asset View Templates\n  }\n</code></pre> <p>This is a more complete, but a bit outdated overview, including a number of helper classes:</p> <p></p>"},{"location":"asset_system/fundamentals/from_file_browser_to_asset_system/","title":"From File Browser to Asset System","text":"<p>Asset functionality used to be built entirely on top of the File Browser. The asset system is supposed to change that, and the transition to it is ongoing. This has important implications on the current code.</p>"},{"location":"asset_system/fundamentals/from_file_browser_to_asset_system/#the-file-browser-as-asset-browser","title":"The File Browser as Asset Browser","text":"<p>The initial introduction of asset functionality focused on delivering an Asset Browser to deal with ID data-blocks that were marked as assets. The File Browser seemed like a good starting point, since it served similar needs on the front- and backend (support for asynchronous recursive loading of directories and .blend file contents, asynchronous preview loading, filtering, ...). However, the File Browser started showing a number of significant issues, and requirements changed too: Assets should now become a first class citizen throughout Blender, with access from outside the Asset Browser as well.</p> More info: Problems with the File Browser as Asset Browser <p> Examples of problems the file browser based design was showing:</p> <ul> <li>Scrolling through big libraries (a few thousand assets) would cause minute long freezes. Cause was the preview loading which tries to be smart and fails miserably. This is not easy to address in the current design.</li> <li>Code was becoming difficult to manage. Too many <code>if (is asset browser) {...} else {...}</code> like bits and lots of special handling for assets.</li> <li>Awkward Python API integration: Asset information needed to be available through BPY, which had to be done by exposing the fact that assets are implemented as files in the Python API. There was no other persistent enough type that could be used and there was no time to implement something proper. Main relicts of that are <code>AssetHandle</code> and <code>bpy.context.asset_file_handle</code>.</li> <li>Changed requirements:  Now assets should become available anywhere in the UI, for example in search menus, add menus, or asset shelves that can be accessed within 3D Views and other editors. So global access to assets with efficient storage management was needed, the per-editor storage of the Asset/File Browser wasn't enough anymore.</li> </ul> <p>Out of this, the asset system design was born. It would be a globally accessible system, optimized for the asset functionality wanted in Blender and ready for the future. </p> <p>Asset functionality should be completely detached from the file browser, both backend and frontend. Instead the asset system should be developed further as basis for all asset functionality and UIs.</p>"},{"location":"asset_system/fundamentals/from_file_browser_to_asset_system/#state-of-the-transition","title":"State of the Transition","text":"<p>Most of the backend responsibilities have been moved to the asset system already. The file browser still performs the loading and unloading of asset libraries and previews from disk, which should be replaced with the asset loader design (T103188 - Asset System: Asset Library Loader). Global access to assets can happen via the Asset List API, see below.</p> More on how the file browser backend and asset system interact.. <p> The file browser backend in <code>filelist.cc</code> contains the functionality for recursive and asynchronous reading of asset libraries and previews from disk. In a thread, it first triggers loading of the basic asset library data (which includes loading asset catalog definition files from disk). It then reads all necessary data for individual assets from disk and passes that on to the asset library to create new asset representations. When the asset representations aren't needed anymore (e.g. when the asset browser is closed, or the asset library changed), it has to remove the asset representations again. So the file-list is entirely responsible for managing the lifetime of the asset representations that are stored in the asset libraries of the asset system. Previews are loaded in a separate pass, the asset system is not involved there yet.</p> <p>For the frontend the asset browser still uses the file browser code. Work is ongoing to change that: The plan is to have the layouts be created through reusable standard components (so called views), managed by the core user interface code. Both the file browser and asset browser would use this, greatly simplifying their code (T95653: Split Asset and File Browser, implement Grid View).</p>"},{"location":"asset_system/fundamentals/from_file_browser_to_asset_system/#asset-list-api","title":"Asset List API","text":"<p>The asset list API is an intermediate step towards the asset system. It is an asset centric abstraction for the file browser backend, and is meant to make assets and asset libraries globally accessible. If you want to access assets outside of the asset browser, this is the place to look at.</p> <p>See Backend &gt; Asset List API for details.</p>"},{"location":"asset_system/fundamentals/from_file_browser_to_asset_system/#designs-to-be-deprecated","title":"Designs to be Deprecated","text":"<p>As the transition progresses, some designs should be deprecated</p> <ul> <li><code>AssetHandle</code>/<code>bpy.types.AssetHandle</code> - at least <code>AssetHandle.file_data</code> should be removed. An <code>AssetRepresentation</code> [TODO link] type is much better suited.</li> <li><code>bpy.context.asset_file_handle</code></li> <li>Asset list API: Currently serves as loader and accessor for asset library data only. Should be replaced with a proper asset library loader design. [TODO link]</li> </ul>"},{"location":"asset_system/user_interface/","title":"User Interface","text":""},{"location":"asset_system/user_interface/asset_browser/","title":"Asset Browser","text":""},{"location":"asset_system/user_interface/asset_shelf/","title":"Asset Shelf","text":"<p>An Asset Shelf provides fast and convenient access to assets from specific editors, without having to open an Asset Browser. It is optimized for using assets for a specific task (for example animating with pose assets, or painting with brush assets), and as such is more limited in functionality than the Asset Browser, but more efficient for certain contexts of use.</p> <p></p> <p>The asset shelf uses the All asset library, and makes use of asset catalogs for efficient navigation within it.</p> <p>Not all editors support asset shelves. Enabling them for a new editor requires some work, as explained below.</p>"},{"location":"asset_system/user_interface/asset_shelf/#source-code-locations","title":"Source Code Locations","text":"<p>Most asset shelf code can be found in:</p> Location Description <code>source/blender/editors/asset/intern/</code><code>asset_shelf_xxx.cc</code> Main asset shelf source files. <code>source/blender/editors/asset/</code><code>ED_asset_shelf.h</code> API to integrate asset shelves in editors. <code>source/blender/blenkernel/</code><code>BKE_screen.h</code> <code>AssetShelfType</code> definitions. <code>source/blender/makesdna/</code><code>DNA_screen_types.h</code> DNA type declarations (supporting file read/write):  <code>AssetShelf</code>, <code>AssetShelfSettings</code>, <code>AssetShelfHook</code> <code>source/blender/makesrna/</code><code>rna_ui.c</code> RNA integration (the Python API is generated from this). <code>scripts/startup/bl_ui/</code><code>asset_shelf.py</code> Generic asset shelf UI elements."},{"location":"asset_system/user_interface/asset_shelf/#custom-asset-shelves","title":"Custom Asset Shelves","text":"<p>To display an asset shelf in a specific context, and for specific kinds of assets, a new asset shelf type can be registered. In Python this works like this: <pre><code>class VIEW3D_AST_sculpt_brushes(bpy.types.AssetShelf):\n    bl_space_type = \"VIEW_3D\"\n\n    @classmethod\n    def poll(cls, context):\n        return bool(context.object and context.object.mode == 'SCULPT')\n\n    # Temporary design!\n    @classmethod\n    def asset_poll__(cls, asset):\n        return asset.file_data.id_type == 'BRUSH'\n</code></pre></p> <p>This will display an asset shelf in sculpt mode, for assets that are of ID type <code>BRUSH</code>.</p> <p>Temporary Design</p> <p> The <code>asset_poll__</code> method is meant as a temporary design solution. In future this should be handled via a <code>bl_traits</code> dictionary or list (i.e. <code>bl_traits = {'BRUSH'}</code>). Blender's Python API doesn't support this syntax for defining a collection of strings using dictionaries or lists yet.</p> <p>A template for this can be found in the Text Editor under Templates &gt; Python &gt; Ui Asset Shelf.</p>"},{"location":"asset_system/user_interface/asset_shelf/#custom-activation-behavior","title":"Custom Activation Behavior","text":"<p>When clicking on an asset, it becomes active in the UI. For the asset shelf you'd often want this to apply some asset, e.g. to apply the clicked on pose asset or activate the clicked on brush asset. This can be done by overriding the keymap item for clicking in the asset shelf.</p> <p>In the <code>register()</code> function of a script/add-on (using the pose library as an example here):</p> <pre><code># Asset Shelf\nkm = wm.keyconfigs.addon.keymaps.new(name=\"Asset Shelf\")\n# Click to apply pose.\nkmi = km.keymap_items.new(\"poselib.apply_pose_asset\", \"LEFTMOUSE\", \"CLICK\")\naddon_keymaps.append((km, kmi))\n</code></pre> <p>The asset shelf provides context that the operator of the keymap item can use, see Context.</p>"},{"location":"asset_system/user_interface/asset_shelf/#custom-drag-drop-behavior","title":"Custom Drag &amp; Drop Behavior","text":"<p>The behavior for dragging can be overridden in a similar fashion. However, the default asset dragging has to be disabled in the asset shelf type definition first:</p> <pre><code>class VIEW3D_AST_pose_library(bpy.types.AssetShelf):\n    # ...\n    bl_options = {'NO_ASSET_DRAG'}\n    # ...\n</code></pre> <p>And then override the keymap item for dragging in the asset shelf: <pre><code># Asset Shelf\nkm = wm.keyconfigs.addon.keymaps.new(name=\"Asset Shelf\")\n# Drag to blend pose.\nkmi = km.keymap_items.new(\"poselib.blend_pose_asset\", \"LEFTMOUSE\", \"CLICK_DRAG\")\naddon_keymaps.append((km, kmi))\n</code></pre></p>"},{"location":"asset_system/user_interface/asset_shelf/#custom-context-menu","title":"Custom Context Menu","text":"<p>Customizing the context menu for the asset shelf and a specific asset is trivial too:</p> <pre><code>class VIEW3D_AST_pose_library(bpy.types.AssetShelf):\n    # ...\n\n    @classmethod\n    def draw_context_menu(cls, context, asset, layout):\n        layout.operator(...)\n\n        # ... More regular layout code\n</code></pre>"},{"location":"asset_system/user_interface/asset_shelf/#asset-shelf-management","title":"Asset Shelf Management","text":""},{"location":"asset_system/user_interface/asset_shelf/#available-asset-shelf-types","title":"Available Asset Shelf Types","text":"<p>Note that the asset shelf type is registered for a specific editor type, 3D View in the example above. When an editor of this type is shown, its registered asset shelf types are polled on every redraw. Once the <code>poll()</code> of an asset shelf type returns <code>True</code>, that indicates that this asset shelf type is available. The system can then try to restore a previously instanced asset shelf of this type, or create a new one if needed.</p>"},{"location":"asset_system/user_interface/asset_shelf/#multiple-available-asset-shelf-types","title":"Multiple Available Asset Shelf Types","text":"<p>It is possible that multiple asset shelf types are available (i.e. multiple shelf types return <code>True</code> in their <code>poll()</code> in a given context). To keep the system simple, only one shelf can be visible in an editor at a time. This is considered to be the active shelf. The user could be presented with a selector to choose from one of the available asset shelf types when necessary, but this isn't implemented yet.</p> <p>Previously active shelves are kept in memory. When the active shelf becomes unavailable, these previously active ones get polled in order from most recently to least recently activated. So as context changes, the most recently used asset shelves get priority in determining the new shelf to activate. Otherwise, the first registered asset shelf type that is available will be used to create a new asset shelf to activate from.</p> <p>Alternative Solution</p> <p> The alternative would be merging settings from multiple asset shelves into a runtime asset shelf. When writing the asset shelves to a file, they could all be written with the same settings (or somehow be split?). This could be done but doesn't seem necessary for now.</p>"},{"location":"asset_system/user_interface/asset_shelf/#ui-components","title":"UI components","text":""},{"location":"asset_system/user_interface/asset_shelf/#regions","title":"Regions","text":"<p>The asset shelf is split in two regions:</p> Main Region The region displaying the assets in a grid-view  (see views documentation). This region uses paginated scrolling and strict region size snapping, so that it always 1 or more full row of assets, never a partial asset row. Region types: <code>RGN_TYPE_ASSET_SHELF</code> in C, <code>ASSET_SHELF</code> in Python. Footer Region Contains display options, filter controls and the catalog tabs. Region type: <code>RGN_TYPE_ASSET_SHELF_FOOTER</code> in C, <code>ASSET_SHELF_FOOTER</code> in Python."},{"location":"asset_system/user_interface/asset_shelf/#asset-view","title":"Asset View","text":"<p>See <code>asset_shelf_asset_view.cc</code>.</p> <p>The main region displays assets in a grid-view using the UI view system for its layout. It defines default drag controllers, and calls the necessary callbacks of the asset shelf type, such as the <code>draw_context_menu()</code> method. The asset view uses the asset list API to fetch the asset library.</p>"},{"location":"asset_system/user_interface/asset_shelf/#asset-catalog-selector","title":"Asset Catalog Selector","text":"<p>See <code>asset_shelf_catalog_selector.cc</code>.</p> <p>The asset catalog selector uses a tree-view for its layout. Its main puprose is to enable or disable asset catalogs in the settings of the asset shelf (<code>AssetShelfSettings.enabled_catalog_paths</code>). The displayed tree is the merged tree, so multiple catalogs with the same path show up as a single element in the tree. To be able to display the catalog tree, it loads the asset library using the asset list API (although it should already be loaded by the Asset View).</p>"},{"location":"asset_system/user_interface/asset_shelf/#context","title":"Context","text":"<p>Asset shelves broadcast data to context while one of the asset shelf regions is active in context (e.g. while the mouse hovers one and nothing overrides it).</p> <p>The following data members are added:</p> <code>\"asset_shelf\"</code> The active shelf, if any (<code>AssetShelf</code>). <code>\"asset_library_ref\"</code> The asset library reference currently visible in the active shelf (<code>AssetLibraryReference</code>) <code>\"active_file\"</code> The file representing the asset. Temporary workaround, should be replaced by a proper asset representation or handle (<code>FileDirEntry</code>)."},{"location":"asset_system/user_interface/asset_shelf/#storage","title":"Storage","text":"<pre><code>classDiagram\n  direction LR\n  View3D --&gt; \"1\" AssetShelfHook\n  AssetShelfHook --&gt; \"*\" AssetShelf\n  AssetShelf --* AssetShelfSettings: Contains\n  AssetShelf --* AssetShelfType: Contains</code></pre> <p>Asset shelves store their data mostly through the following structs:</p> <code>AssetShelfHook</code> Container for spaces to embed all permanent asset shelf data. This contains a list of <code>AssetShelf</code> instances (the storage of previously active asset shelves) and information on the active shelf. Availability of the active shelf is queried on redraws, so the active shelf may change on context changes. <code>AssetShelf</code> Data of a single shelf, created by activating a shelf of a given <code>AssetShelfType</code>. Holds type information and settings, whereby settings are stored in a nested <code>AssetShelfSettings</code> member. <code>AssetShelfSettings</code> The settings for an <code>AssetShelf</code> instance such as the enabled asset catalogs and other display options. See <code>asset_shelf_settings.cc</code>. <code>AssetShelfType</code> Runtime type information like the identifier and callbacks of the asset shelf. <p>Except of the runtime-only <code>AssetShelfType</code>, these structs are part of SDNA so they can be written to .blend files.</p>"},{"location":"asset_system/user_interface/asset_shelf/#adding-asset-shelf-support-to-an-editor-type","title":"Adding Asset Shelf Support to an Editor Type","text":"<p>Making Asset Shelves available in an editor is not too hard, but requires some work still. The <code>ED_asset_shelf.h</code> header contains most public functions required for this. The following is a rough checklist to follow (not too specific since this can get outdated quickly).</p> <p>TODO</p> <ul> <li>Add <code>AssetShelfHook</code> to the space data of the editor, and call the duplicate, file read and file write functions from the necessary places.</li> <li>Keymap?</li> <li>Theme options?</li> </ul>"},{"location":"asset_system/user_interface/asset_shelf/#faq","title":"FAQ","text":"Is it one asset shelf or multiple? <p>For the user, it is usually enough to refer to the two regions at the bottom with their contents as asset shelf. In more precise language, these can be considered the asset shelf regions, with contents defined by the active asset shelf data and the asset shelf type it was instantiated from. So multiple asset shelves are kept in storage (each of a different type), but only one is active (as in: visible) at a time.</p>"},{"location":"contributing/","title":"Contribute Documentation","text":"<p>This documentation is built using Material for MkDocs. This provides a simple developer-oriented workflow with the familiar Markdown language for writing.</p> <p>You can conveniently edit files via Gitea and submit the changes for review, or build a local version of the full documentation for off-line editing.</p>"},{"location":"contributing/building/","title":"Building this Documentation","text":""},{"location":"contributing/building/#1-get-the-sources","title":"1. Get the Sources","text":"<p>In a directory of your choice (assumes <code>git</code> is installed): <pre><code>$ git clone https://github.com/julianeisel/devdocs.git\n$ cd devdocs\n</code></pre></p>"},{"location":"contributing/building/#2-install-dependencies","title":"2. Install Dependencies","text":"<p>Install Material for MkDocs and all the necessary extensions/plugins:</p> <p><pre><code>sudo python -m pip install -r requirements.txt\n</code></pre> You may have to use <code>python3</code> instead of <code>python</code>.</p>"},{"location":"contributing/building/#3-build","title":"3. Build","text":""},{"location":"contributing/building/#live-edit","title":"Option 1: Build and Live Reload","text":"<p>While working on the documentation, it is useful to use the live reloading feature from MkDocs: <pre><code>mkdocs serve\n</code></pre> This will print a URL under which you will find the latest build of your documentation that is updated continuously while working on it.</p>"},{"location":"contributing/building/#option-2-build-only","title":"Option 2: Build only","text":"<p>To only build the documentation without serving it: <pre><code>mkdocs build\n</code></pre></p> <p>This will print a folder containing the <code>index.html</code> to open in a web browser.</p>"},{"location":"contributing/editing/","title":"Editing","text":""},{"location":"contributing/editing/#live-editing","title":"Live Editing","text":"<p>When editing in a local build of this documentation, it's recommended to use live reloading. This automatically refreshes your browser to reflect changes when you save an edited file.</p>"},{"location":"contributing/editing/#adding-pages","title":"Adding Pages","text":"<p>When adding a page, make sure to register it in the <code>nav</code> section of <code>mkdocs.yml</code>. Otherwise the page will not show up for navigation.</p>"},{"location":"contributing/editing/#addingenabling-extensions-plugins","title":"Adding/Enabling Extensions &amp; Plugins","text":"<p>Extensions and plugins are controlled via the <code>mkdocs.yml</code> file. If additional Python modules are necessary for one, they must be added to the <code>requirements.txt</code> file.</p>"},{"location":"contributing/editing/#configuring-settings-extensions-plugins-etc","title":"Configuring (Settings, Extensions, Plugins, etc.)","text":"<p>Settings, including the enabled extensions and plugins are controlled via the <code>mkdocs.yml</code> file.</p>"},{"location":"contributing/license/","title":"License","text":"<p>The content of this documentation is available under a Creative Commons Attribution-ShareAlike 4.0 International License or any later version. Excluded from the CC-BY-SA are also the used logos, trademarks, icons, source code and Python scripts.</p>"},{"location":"core_data_management/","title":"Core Data Management","text":"<p>Dummy page.</p>"},{"location":"core_data_management/blend_file_read_write/","title":"Blend-File Read/Write","text":"<p>Dummy page.</p>"},{"location":"core_data_management/blend_file_read_write/dummy_page/","title":"Dummy page","text":"<p>Dummy page.</p>"},{"location":"core_data_management/datablocks_and_main_database/","title":"Datablocks and Main Database","text":"<p>Dummy page.</p>"},{"location":"core_data_management/datablocks_and_main_database/dummy_page/","title":"Dummy page","text":"<p>Dummy page.</p>"},{"location":"core_data_management/undo_redo/","title":"Undo/Redo","text":"<p>Dummy page.</p>"},{"location":"core_data_management/undo_redo/dummy_page/","title":"Dummy page","text":"<p>Dummy page.</p>"},{"location":"developer_handbook/","title":"Blender Developer Handbook","text":"<p>This is the Blender Developer Handbook. It tries to provide all the necessary general information needed to develop Blender. As such it is not only aimed at beginner developers, experienced developers use this handbook too.</p> <p>Proof of Concept</p> <p> The entire structure of the handbook is just another proof of concept. Pages are empty or don't even exist. Expect a bunch of 404 links.</p>"},{"location":"developer_handbook/building_blender/","title":"Building Blender","text":""},{"location":"developer_handbook/new_developer_introduction/","title":"New Developer Introduction","text":""},{"location":"developer_handbook/new_developer_introduction/#new_developer_info","title":"New Developer Info","text":"<p><pre><code>{{Template:Lead|\nThis page is meant to provide new developers with information about how the Blender development process works, where to find info and how to find a good project to work on.\n}}\n</code></pre> Communication</p> <p>There are various communication channels used.</p> <ul> <li>BF-Committers Mailing     List -     for public discussions, where official decisions are made.</li> <li>Issue Tracker - for bugs, code     contributions and managing design tasks.</li> <li>Blender Chat -     #blender-coders for     informal conversation and discussions with/between developers.</li> <li>DevTalk Forum - for general     developer discussion &amp; questions.</li> </ul> <p>See the Contact page for more information.</p> <p>If you want to start developing in Blender you will have lots of startup questions. You can ask them in the #blender-coders blender.chat channel each day of the week.</p> <p>When in doubt and no particular channel seems to match your question, mail the bf-committers mailing list and you will get an answer there or get redirected to the right channel.</p> <p>No spamming or flaming on the lists or other channels is allowed. Please stay on topic in the lists, and follow good net etiquette. Also do not send html messages to the mailing lists. Html messages can be contain a variety of security problems and as such tend to be mistrusted by many people.</p>"},{"location":"developer_handbook/new_developer_introduction/#module_meetings","title":"Module Meetings","text":"<p>The modules have autonomy to organize their work how they see fit. Some modules have weekly or bi-weekly meetings. The less active modules meet once there is something specific to discuss. The future meetings are announced as part of the meeting notes.</p>"},{"location":"developer_handbook/new_developer_introduction/#getting_started","title":"Getting Started","text":""},{"location":"developer_handbook/new_developer_introduction/#building_blender","title":"Building Blender","text":"<p>See Building Blender.</p>"},{"location":"developer_handbook/new_developer_introduction/#decisions","title":"Decisions","text":"<p>Blender development is structured similarly to Python\\'s BDFL model (BDFL stands for Benevolent Dictator For Life). The idea is that the project is managed by one person, in this case Ton Roosendaal, who delegates design decisions to a group of module owners, while still maintaining a veto right of what goes into Blender.</p>"},{"location":"developer_handbook/new_developer_introduction/#your_first_project","title":"Your First Project","text":"<p>Once you have blender compiled you\\'re probably wondering where to start tinkering. If you are a Blender user then there is probably some niggling thing you would like to add or change. If you are new to Blender then you will need to take a look and see what you might work on.</p> <p>There are no hard and fast rules about where to start, so find an area that interests you and start looking onto it.</p> <p>A good location to start checking on what is on the roadmaps for modules is the list on the front page of projects.blender.org.</p> <p>Some hints for your first projects:</p> <ul> <li>An area of interest (even better, an area of Blender you use)</li> <li>Double check it is not already done.</li> <li>Try to avoid a project that spans across many files and areas of     Blender, since you may get bogged down trying to understand     everything at once.</li> </ul> <p>Here are some areas that can give you a foot in the door:</p>"},{"location":"developer_handbook/new_developer_introduction/#small_features","title":"Small Features","text":"<p>Adding in small features is a good way to start getting your hands dirty, even if you don\\'t contribute the changes. The feature you worked on can evolve into something more useful, take a new direction, or spark interest in new areas to develop.</p> <p>Here is a list of quick hacks - tasks that core developers think could be reasonably tackled as a first blender project without a major time commitment (these tasks typically would take a core developer less than 4 hours to accomplish, but might take quite a bit more time for a new coder who needs to learn the code base).</p>"},{"location":"developer_handbook/new_developer_introduction/#bug_fixing","title":"Bug Fixing","text":"<p>One of the easiest ways to get involved with coding Blender is by fixing bugs. Bug-fixing lets you focus on a small part of the Blender source rather than trying to understand it all at once. The list of current bugs is on projects.blender.org. So pick an area of interest and start fixing! When you have got it, make a pull request.</p>"},{"location":"developer_handbook/new_developer_introduction/#navigating_the_code","title":"Navigating the Code","text":"<p>Have a look at the Files structure and Code Layout diagram.</p> <p>The editors directory is usually a good place - it is where most of the operators live. Have a look at the header files and structs related to what you are interested in working on. The headers usually have the best overview of what a function does. To find the struct a simple grep or other search for struct Foo.</p> <p>You can also start with writing python scripts, the API for our python tools - is similar in many ways to our C API. You can often find out where some C code lives by seeing the python tool tips by hovering over a button and seeing what the operator name is. If you add a console window you can see what is output to it when you do an action, then just search the code.</p> <p>Also putting a break on a function in a debugger and doing a back trace can help you find the path code took to get to your function of interest. Or you can start blender from the command line with the -d option and every command is printed to the console.</p>"},{"location":"developer_handbook/new_developer_introduction/#debugging","title":"Debugging","text":"<p>Have a look at Debugging for help and hints on doing debugging. If you end up not being able to solve the bug yourself, post a bug to our Bug Tracker, if it is a bug in our code.</p> <p>If it is a bug in your code, load your test file and the information you have found out about the bug to pasteall.org then ask for help in #blender-coders on blender.chat. If no-one can help you there you can try emailing bf-committers\\@blender.org.</p>"},{"location":"developer_handbook/new_developer_introduction/#development_process","title":"Development Process","text":"<p>Steps for getting a change into Blender</p> <ol> <li>Find an area in Blender you want to improve upon.</li> <li>If it\\'s a non-trivial feature, check in advance if Blender     developers agree with the project and design, to avoid doing work     for nothing. Contacting developers is typically done on the     developer forums, or on     #blender-coders on     blender.chat. To talk to the individual owners of parts of the code,     see the list of module owners</li> <li>Do the actual coding :)</li> <li>Once you have code, see the Contributing     Code section on how to make     a pull request get it submitted,     reviewed and included.</li> </ol>"},{"location":"developer_handbook/new_developer_introduction/#technical_documentation","title":"Technical Documentation","text":"<p>We encourage everyone to use the Blender Wiki to document code work and to share proposals. Note that we strictly apply the rule \\\"No code gets in trunk without documentation!\\\". Also never hesitate to include good example .blend files and tests and videos showing the feature.</p> <p>People who only want to help with technical documentation are welcome too. Just use the general contact information here to get started.</p>"},{"location":"developer_handbook/new_developer_introduction/#release_process","title":"Release Process","text":"<p>For more information about the release schedule, see Release Cycle and Current Projects to understand the schedule and times when new features can get in and releases are made.</p>"},{"location":"developer_handbook/new_developer_introduction/advice/","title":"Advice","text":""},{"location":"developer_handbook/new_developer_introduction/advice/#advice_for_new_developers","title":"Advice for New Developers","text":""},{"location":"developer_handbook/new_developer_introduction/advice/#preface","title":"Preface","text":"<p>Every so often we have emails on the Blender mailing list with subjects like: \\\"I\\'d like to get involved with Blender development\\\".</p> <p>This page is intended as a reply from active developers, giving practical advice to anyone who\\'s new to Blender development and wants to get involved.</p> <p>While there is no shortage of technical documentation for nearly every aspect of development,\\ this page focuses on how to approach taking your first steps.</p>"},{"location":"developer_handbook/new_developer_introduction/advice/#get_blender_building","title":"Get Blender Building","text":"<p>Before thinking ahead too much and asking lots of questions about the code - just get Blender building.</p> <p>See: Building Blender.</p>"},{"location":"developer_handbook/new_developer_introduction/advice/#setup_a_development_environment","title":"Setup a Development Environment","text":"<p>While a lot could be written about editors and IDE\\'s and editors, here are some suggestions:</p> <ul> <li>Using any programmers text editor with a search tool (even grep), is     fine for C or Python development.</li> <li>You may want to use different editors, one for Python, another for     C/C++.\\     (since we use different indentation settings, some edits such as     Vim/Emacs allow per-filetype indentation configuration)</li> <li>IDE\\'s are more useful for C++ code, especially areas that use class     inheritance since it\\'s often not so obvious which members are     available.</li> <li>Some IDE\\'s may have trouble with Blender!\\     Blender source code is large enough that some IDE\\'s are unusably     slow.\\     While not wanting to promote specific technologies, here\\'s a     short-list of IDE\\'s known to work well for Blender development.<ul> <li>For Windows: Visual Studio MSVC is a popular choice.</li> <li>For OSX: XCode.</li> <li>For Linux there are a few options\\     VS Code and QtCreator are popular choices, KDevelop is usable     too, Eclipse &amp; Netbeans are functional but can be slow.</li> </ul> </li> </ul> Notes: -   All IDE\\'s mentioned support CMake for generating project     files.\\ -   Some Blender developers don\\'t use IDE\\'s at all, with     experience you may want use a development environment not     mentioned here.\\     The list above is just suggesting some starting points known to     work for others."},{"location":"developer_handbook/new_developer_introduction/advice/#initial_development_setup","title":"Initial Development Setup","text":"<p>Whether you\\'ve already chosen your development tools, or you\\'re just getting started, once you can compile the code:</p> <p>At a minimum you must be able to do these operations on the entire code-base quickly and easily:</p> <ul> <li>Edit source code.</li> <li>Lookup any file by name, for editing.</li> <li>Search all text in the source code.\\     (function names, tool-tips, comments... etc).</li> </ul> <p>If you aren\\'t sure how to do any of the operations above, take some time to investigate how to perform them, otherwise basic navigation of the source will be unnecessarily difficult.</p> <p>See: Development Environment Setup.</p>"},{"location":"developer_handbook/new_developer_introduction/advice/#note_on_configuration","title":"Note on Configuration","text":"<p>At a minimum you\\'ll need to configure your editor/IDE ...</p> <ul> <li>Set indentation to spaces, width 2 for C/C++.</li> <li>Set indentation to spaces, width 4 for Python.</li> </ul> <p>For details see: Code Style Configuration.</p>"},{"location":"developer_handbook/new_developer_introduction/advice/#pick_a_project","title":"Pick a Project","text":"<p>So you\\'re all ready to go, it\\'s time to pick some project, this is difficult to give good general advice for since it\\'s entirely up to your needs/interests.\\ Having said that, here are some things to consider.</p> <ul> <li>In most cases we suggest to start really small and treat it as an     exercise, your first project may not end up being useful and even     things you would expect to be easy might not be.\\     This also helps you become used to navigating the source code,     reading it, making edits - and understanding it. While you do this     you can think of more ambitious/interesting things to change too, so     this time isn\\'t wasted.</li> <li>As for what to work on, feel free to ask around but everyone will     give different suggestions.<ul> <li>Add a Feature - This is often the most fun but before     spending a lot of time on this it\\'s best to find out if the     feature would even be accepted, some features are intentionally     not added to Blender because they don\\'t fit well with the     existing design.\\     Look into our Good First     Issue     page for a list of approved projects, suitable for beginners.</li> <li>Improve a Feature - When using Blender you might run into     some simple limitation - Lasso select tool didn\\'t work on UV     editor for example, or that the smooth tool doesn\\'t work on a     lattice\\     Making improvements like this is good because you\\'re working     within the current design and there\\'s a much higher chance of     having your work accepted.</li> <li>Fix a bug - take care with this, bug fixes are welcome of     course but can often be quite complicated to investigate and you     may end up spending a lot of time and still not find a fix.\\     Hint, recently reported bugs are often less trouble to     resolve!</li> <li>Janitor Work - To get a patch accepted and to get to know     the code, contact developers and to generally follow the whole     process; more mundane patches can still help you get involved.<ul> <li>tooltip/spelling corrections.</li> <li>fixes/improvements to the build-system.</li> <li>quiet compiler warnings.</li> <li>installer / packaging improvements.</li> </ul> </li> </ul> </li> <li>Avoid small patches which only tweak existing behavior or tweaks to     defaults (early on at least). These kinds of changes are very easy     for existing developers to make, so it\\'s not really all that     helpful to send such opinionated patches.\\     It\\'s common for people to come to Blender from other software and     want to make it work how they like, but it\\'s not the purpose of     Blender to be a clone of another application.\\     At least learn the Blender way before trying to make Blender     behave like some other application, perhaps what you want can be     done with key-map modifications, or added as a user preference, but     to start with it\\'s best to avoid controversial changes.\\<ul> <li>You risk spending too long on discussions with existing maintainers - before you have a good understanding of internal workings.</li> </ul> </li> <li>For a definitive answer on whether your project might be accepted -     talk to the developer(s) who would review your work:\\     See: Module Owners.</li> </ul>"},{"location":"developer_handbook/new_developer_introduction/advice/#communicate_with_other_developers","title":"Communicate with Other Developers","text":"<p>Normally when you start out you\\'ll have lots of questions, not all of them can be documented - so here are the 3 main ways Blender developers communicate.</p> <ul> <li>Join the bf-committers mailing     list.</li> <li>Join the Devtalk forums.</li> <li>Talk with developers and users on     #blender-coders.</li> </ul>"},{"location":"developer_handbook/new_developer_introduction/advice/#further_suggestions","title":"Further Suggestions","text":"<ul> <li>Disable most features when building Blender (OpenVDB, Collada,     FFMpeg, Cycles, LibMV... etc) - will speed up rebuilds     considerably.\\     Unless you intend to develop on any of these areas of course.</li> <li>While you will eventually want to use a debugger to step over the     source,\\     try using <code>printf()</code> for debugging, sometimes if you\\'re not sure of     how something works it\\'s good to add prints into the code, for your     own code or even if you read it and want to understand it better,     this is a very simple/stupid way to check on things but handy, fast     rebuilds make this less of a hassle.</li> </ul>"},{"location":"developer_handbook/new_developer_introduction/advice/#things_to_learn","title":"Things to Learn","text":"<p>Here are things you\\'ll probably want to learn as you get into development.</p> <ul> <li>Learn to search the source code *efficiently*\\     (if you see a word in the interface, chances are searching for it     will take you to the code related to it, or close enough).</li> <li>Learn basic regex (many search tools &amp; IDE\\'s support them), it     looks confusing but you can find some cheat sheets online to help.</li> <li>Learn how to create and apply patches (to share your changes with     others)</li> <li>Learn to use a debugger to at minimum check the file and line number     of a crash (view a stack trace).</li> <li>Use git to make temporary branches, stashing changes and apply     patches.\\     Allow for some time to become comfortable using git, initially     simply updating is enough to get started, but eventually you will     want to use some of it\\'s more advanced features.</li> <li>Use \\'<code>git blame</code>\\' to find who changed some line of code, when and     why.</li> <li>Rather than guessing why something is slow, use a profiler - there     are many profilers around and from my experience they all have     tradeoffs between setup time, execution speed and useful output.</li> <li>If you\\'re debugging memory related errors on Linux.\\     Try     Valgrind     or     Address-Sanitizer,     they\\'re very useful tools and in some cases can save hours of     tedious troubleshooting.</li> </ul>"},{"location":"developer_handbook/new_developer_introduction/advice/#other_info","title":"Other Info","text":"<ul> <li>Often new devs ask what languages Blender is written in, you can     check OpenHub for source code statistics/info\\     https://www.openhub.net/p/blender/analyses/latest/languages_summary</li> <li>If you want to follow blender mailing lists without subscribing you     can use markmail which has a useful search too\\     http://blender.markmail.org</li> <li>For an overview of what to expect getting involved with development     (that skips practical matters),\\     See:     http://blenderartists.org/forum/showthread.php?200013-develop-and-improve-the-source-code-of-blender&amp;p=1721623&amp;viewfull=1#post1721623</li> </ul> <p><pre><code>&lt;!-- --&gt;\n</code></pre> -   Official page for new-developers - see:\\     http://wiki.blender.org/wiki/Developer_Intro/Overview -   For a general developer FAQ - see\\     http://wiki.blender.org/wiki/Reference/FAQ</p>"},{"location":"developer_handbook/tools/","title":"Tools","text":"<p>This is the Blender Developer Handbook. It will guide you through all the basic information needed so you can start developing Blender.</p>"},{"location":"eevee_and_viewport/","title":"Eevee &amp; Viewport","text":""},{"location":"eevee_and_viewport/#gpu-module","title":"GPU module","text":"<ul> <li>GPU Module</li> <li>Vulkan Backend</li> </ul>"},{"location":"eevee_and_viewport/#draw-manager","title":"Draw Manager","text":""},{"location":"eevee_and_viewport/gpu/","title":"GPU Module","text":"<p>The GPU module is an abstraction layer between Blender and an Operating System Graphics Library layer (GL). These GLs are abstracted away in GPUBackends. There is a GLBackend that provides support to OpenGL 3.3 on Windows, Mac and Linux. There is also a Metal backend for Apple devices. Vulkan backend is currently in development.</p> <p>GPU module can be used to draw geometry or perform computational tasks using a GPU. This overview is targeted to developers who want to have a quick start how they can use the GPU module to draw or compute. Basic knowledge of an GL (OpenGL core profile 3.3 or similar) is required as we use similar concepts.</p>"},{"location":"eevee_and_viewport/gpu/#drawing-pipeline","title":"Drawing pipeline","text":"<p>This section gives an overview of the drawing pipeline of the GPU module.</p> <pre><code>classDiagram\ndirection LR\n\nclass GPUBatch\nclass GPUShader {\n    -GLSL vertex_code\n    -GLSL fragment_code\n}\nclass GPUFramebuffer\nclass GPUVertBuf\nclass GPUIndexBuffer\nclass GPUPrimType {\n    &lt;&lt;Enumeration&gt;&gt;\n    GPU_PRIM_POINTS,\n    GPU_PRIM_LINES,\n    GPU_PRIM_TRIS,\n    ...\n}\nclass GPUShaderInterface\nclass GPUTexture\n\nGPUBatch o--&gt; GPUIndexBuffer\nGPUBatch o--&gt; GPUVertBuf\nGPUBatch *--&gt; GPUPrimType\nGPUBatch o..&gt; GPUShader: draws using\nGPUShader o..&gt; GPUFramebuffer: onto\nGPUShader *--&gt; GPUShaderInterface\nGPUFramebuffer o--&gt; GPUTexture\n\n</code></pre>"},{"location":"eevee_and_viewport/gpu/#textures","title":"Textures","text":"<p>Textures are used to hold pixel data. Textures can be 1, 2 or 3 dimensional, cubemap and an array of 2d textures/cubemaps. The internal storage of a texture (how the pixels are stored in memory on the GPU) can be set when creating a texture.</p> Create a texture<pre><code>/* Create an empty texture with HD resolution where pixels are stored as half floats. */\nGPUTexture *texture = GPU_texture_create_2d(\"MyTexture\", 1920, 1080, 1, 0, GPU_RGBA16F, NULL);\n</code></pre>"},{"location":"eevee_and_viewport/gpu/#frame-buffer","title":"Frame buffer","text":"<p>A frame buffer is a group of textures you can render onto. These textures are arranged in a fixed set of slots. The first slot is reserved for a depth/stencil buffer. The other slots can be filled with regular textures, cube maps, or layer textures.</p> <p>GPU_framebuffer_ensure_config is used to create/update the configuration of a framebuffer.</p> Create a framebuffer<pre><code>GPUFramebuffer *fb = NULL;\nGPU_framebuffer_ensure_config(&amp;fb, {\nGPU_ATTACHMENT_NONE, // Slot reserved for depth/stencil buffer.\nGPU_ATTACHMENT_TEXTURE(texture),\n})\n</code></pre>"},{"location":"eevee_and_viewport/gpu/#shader-create-info","title":"Shader Create Info","text":"<p>The GPU module supports multiple GL backends. The challenge of multiple GL backends is that GLSL is different on all those platforms. It isn't possible to compile an OpenGL GLSL on Vulkan as the GLSL differs. The big differences between the GLSL's are how they define and locate resources.</p> <p>This section of the documentation will handle how to create GLSL that can safely be cross compiled to different backends.</p>"},{"location":"eevee_and_viewport/gpu/#gpushadercreateinfo","title":"GPUShaderCreateInfo","text":""},{"location":"eevee_and_viewport/gpu/#defining-a-new-compile-unit","title":"Defining a new compile unit","text":"<p>When creating a new compile unit to contain a GPUShaderCreateInfo definition it needs to be added to the <code>SHADER_CREATE_INFOS</code> in <code>gpu/CMakeLists.txt</code> this will automatically register the definition in a registry.</p> <p>Each of the compile unit should include <code>gpu_shader_create_info.h</code>.</p>"},{"location":"eevee_and_viewport/gpu/#interface-info","title":"Interface Info","text":"<p>Interfaces are data that are passed between shader stages (Vertex =&gt; Fragment stage). Attributes can be <code>flat</code>, <code>smooth</code> or <code>no_perspective</code> describing the interpolation mode between.</p> Example interface info<pre><code>GPU_SHADER_INTERFACE_INFO(text_iface, \"\")\n.flat(Type::VEC4, \"color_flat\")\n.no_perspective(Type::VEC2, \"texCoord_interp\")\n.flat(Type::INT, \"glyph_offset\")\n.flat(Type::IVEC2, \"glyph_dim\")\n.flat(Type::INT, \"interp_size\")\n</code></pre>"},{"location":"eevee_and_viewport/gpu/#shader-info","title":"Shader Info","text":"<p>Shader Info describes</p> <ul> <li>Where to find required data (vertex_in, push constant).</li> <li>Textures/samplers to use (sampler)</li> <li>Where to store the final data (fragment_out)</li> <li>It describes the data format between the shader stages (vertex_out).</li> <li>The source code of each stage (vertex_source, fragment_source)</li> </ul> <p>Shader infos can reuse other infos to reduce code duplication (<code>additional_info</code> would load the data from the given shader info into the new shader info.</p> <p>The active GPU backend will adapt the GLSL source to generate those part of the code.</p> Example Shader Info<pre><code>GPU_SHADER_CREATE_INFO(gpu_shader_text)\n// vertex_in define vertex buffer inputs. They will be passed to the vertex stage.\n.vertex_in(0, Type::VEC4, \"pos\")\n.vertex_in(1, Type::VEC4, \"col\")\n.vertex_in(2, Type::IVEC2, \"glyph_size\")\n.vertex_in(3, Type::INT, \"offset\")\n\n// vertex_out define the structure of the output of the vertex stage.\n// This would be the input of the fragment stage or geometry stage.\n.vertex_out(text_iface)\n\n// definition of the output of the fragment stage.\n.fragment_out(0, Type::VEC4, \"fragColor\")\n\n// Flat uniforms aren't supported anymore and should be added as push constants.\n// Note that push constants are limited to 128 bytes. Use uniform buffers\n// when more space is required.\n// Internal Matrices are automatically bound to push constants when they exists.\n// Matrices inside a uniform buffer is the responsibility of the developer.\n.push_constant(0, Type::MAT4, \"ModelViewProjectionMatrix\")\n\n// Define a sampler location.\n.sampler(0, ImageType::FLOAT_2D, \"glyph\", Frequency::PASS)\n\n// Specify the vertex and fragment shader source.\n// dependencies can be automatically included by using `#pragma BLENDER_REQUIRE`\n.vertex_source(\"gpu_shader_text_vert.glsl\")\n.fragment_source(\"gpu_shader_text_frag.glsl\")\n\n// Add all info of the GPUShaderCreateInfo with the given name.\n// Provides limited form of inheritance.\n.additional_info(\"gpu_srgb_to_framebuffer_space\")\n\n// Create info is marked to be should be compilable.\n// By default a create info is not compilable.\n// Compilable shaders are compiled when using shader builder.\n.do_static_compilation(true);\n</code></pre>"},{"location":"eevee_and_viewport/gpu/#shader-source-order","title":"Shader Source Order","text":"<p>Shader source order does not follow the order of the methods call made to the create info. Instead it follows this fixed order:</p> <ul> <li>Standard Defines: GPU module defines (<code>GPU_SHADER</code>, <code>GPU_VERTEX_SHADER</code>, OS, GPU vendor, and extensions) and MSL glue.</li> <li>Create Info Defines: <code>.define</code>.</li> <li>Typedef Sources: <code>.typedef_source</code>.</li> <li>Resources Declarations: <code>.sampler</code>, <code>.image</code>, <code>.uniform_buf</code> and <code>.storage_buf</code>.</li> <li>Layout Declarations: <code>.geometry_layout</code>, <code>.local_group_size</code>.</li> <li>Interface Declarations: <code>.vertex_in</code>, <code>.vertex_out</code>, <code>.fragment_out</code>, <code>.fragment_out</code>.</li> <li>Main Dependencies: All files inside <code>#pragma BLENDER_REQUIRE</code> directives.</li> <li>Main: Shader stage source file <code>.vertex_source</code>, <code>.fragment_source</code>, <code>.geometry_source</code> or <code>.compute_source</code>.</li> <li>NodeTree Dependencies: All files needed by the nodetree functions. Only for shaders from Blender Materials.</li> <li>NodeTree: Definition of the nodetree functions (ex: <code>nodetree_surface()</code>). Only for shaders from Blender Materials.</li> </ul>"},{"location":"eevee_and_viewport/gpu/#buffer-structures","title":"Buffer Structures","text":"<p>Previously structs that were used on CPU/GPU would be written twice. Once using the CPU data types and once that uses the GPU data types. Developers were responsible to keep those structures consistent.</p> <p>Shared structs can be defined in 'shader_shared' header files. For example the <code>GPU_shader_shared.h</code>. These headers can be included in C and CPP compile units.</p> <pre><code>/* In GPU_shader_shared.h */\nstruct MyStruct {\nfloat4x4 modelMatrix;\nfloat4 colors[3];\nbool1 do_fill;\nfloat dim_factor;\nfloat thickness;\nfloat _pad;\n};\nBLI_STATIC_ASSERT_ALIGN(MyStruct, 16)\n</code></pre> <p>Developer is still responsible to layout the struct (alignment and padding) so it can be used on the GPU.</p> <p>Note</p> <p>See [[Style_Guide/GLSL#Shared_Shader_Files|these rules]] about correctly packing members.</p> <pre><code>GPU_SHADER_CREATE_INFO(my_shader)\n.typedef_source(\"GPU_shader_shared.h\")\n.uniform_buf(0, \"MyStruct\", \"my_struct\");\n</code></pre> <p>This will create a uniform block binding at location 0 with content of type <code>MyStruct</code> named <code>my_struct</code>. The struct members can then be accessed also using <code>my_struct</code> (ex: <code>my_struct.thickness</code>).</p> <p>Uniform and storage buffers can also be declared as array of struct like this:</p> <pre><code>GPU_SHADER_CREATE_INFO(my_shader)\n.typedef_source(\"GPU_shader_shared.h\")\n.storage_buf(0, \"MyStruct\", \"my_struct[]\");\n</code></pre> <p>A shader create info can contain multiple 'typedef_source'. They are included only once and before any resource declaration (see gpu shader source ordering).</p>"},{"location":"eevee_and_viewport/gpu/#geometry-shaders","title":"Geometry shaders","text":"<p>Due to specific requirements of certain gpu backend input and output parameters of this stage should always use a named structure.</p>"},{"location":"eevee_and_viewport/gpu/#compute-shaders","title":"Compute shaders","text":"<p>For compute shaders the workgroup size must be defined. This can be done by calling the <code>local_group_size</code> function. This function accepts 1-3 parameters to define the local working group size for the x, y and z dimension.</p> <pre><code>GPU_SHADER_CREATE_INFO(draw_hair_refine_compute)\n/* ... */\n/* define a local group size where x=1 and y=1, z isn't defined. Missing parameters would fallback\n     * to the platform default value. For OpenGL 4.3 this is also 1. */\n.local_group_size(1, 1)\n.compute_source(\"common_hair_refine_comp.glsl\")\n/* ... */\n</code></pre>"},{"location":"eevee_and_viewport/gpu/#c-c-code-sharing","title":"C &amp; C++ Code sharing","text":"<p>Code that needs to be shared between CPU and GPU implementation can also be put into 'shader_shared' header files. However, only a subset of C and C++ syntax is allowed for cross compilation to work:</p> <ul> <li>No arrays except as input parameters.</li> <li>No parameter reference <code>&amp;</code> and likewise <code>out</code> and <code>inout</code>.</li> <li>No pointers or references.</li> <li>No iterators.</li> <li>No namespace.</li> <li>No template.</li> <li>Use float suffix by default for float literals to avoid double promotion in C++.</li> <li>Functions working on floats (ex: <code>round()</code>, <code>exp()</code>, <code>pow()</code> ...) might have different   implementation on CPU and GPU.  <p>Note</p> <p>See {{BugReport|103026}} for more detail.</p> </li> </ul> <p>You can also declare <code>enum</code> inside these files. They will be correctly translated by our translation layer for GLSL compilation. However some rules to apply:</p> <ul> <li>Always use <code>u</code> suffix for enum values. GLSL do not support implicit cast and enums are treated as <code>uint</code> under the hood.</li> <li>Define all enum values. This is to simplify our custom pre-processor code.</li> <li>(C++ only) Always use <code>uint32_t</code> as underlying type (<code>enum eMyEnum : uint32_t</code>).</li> <li>(C only) do '''NOT''' use enum types inside UBO/SSBO structs and use <code>uint</code> instead (because <code>enum</code> size is implementation dependent in C).</li> </ul> <p>See Shader builder for a validation tool for shaders.</p>"},{"location":"eevee_and_viewport/gpu/#shader","title":"Shader","text":"<p>A GPUShader is a program that runs on the GPU. The program can have several stages depending on the its usage. When rendering geometry it should at least have a vertex and fragment stage, it can have an optional geometry stage. It is not recommended to use geometry stages as Apple doesn't have support for it.</p> Create shader<pre><code>GPUShader *sh_depth = GPU_shader_create_from_info_name(\"my_shader\");\n</code></pre> <p>This will lookup the shader create info with the name <code>my_shader</code>, loads and compile the vertex and fragment stage and link the stages into a program that can be used on the GPU. It also generates a GPUShaderInterface that handles lookup to input parameters (attributes, uniforms, uniform buffers, textures and shader storage buffer objects).</p>"},{"location":"eevee_and_viewport/gpu/#geometry","title":"Geometry","text":"<p>Geometry is defined by a <code>GPUPrimType</code>, one index buffer (IBO) and one or more vertex buffers (VBOs). The GPUPrimType defines how the index buffer should be interpreted.</p> <p>Indices inside the index buffer define the order how to read elements from the vertex buffer(s). Vertex buffers are a table where each row contains the data of an element. When multiple vertex buffers are used they are considered to be different columns of the same table. This matches how GL backends organize geometry on GPUs.</p> <p>Index buffers can be created by using a <code>GPUIndexBufferBuilder</code></p> Create Index Buffer<pre><code>GPUIndexBufBuilder ibuf\n/* Construct a builder to create an index buffer that has 6 indexes.\n * And the number of elements in the vertex buffer is 12. */\nGPU_indexbuf_init(&amp;ibuf GPU_PRIM_TRIS, 6, 12);\n\nGPU_indexbuf_add_tri_verts(&amp;ibuf, 0, 1, 2);\nGPU_indexbuf_add_tri_verts(&amp;ibuf, 2, 1, 3);\nGPU_indexbuf_add_tri_verts(&amp;ibuf, 4, 5, 6);\nGPU_indexbuf_add_tri_verts(&amp;ibuf, 6, 5, 7);\nGPU_indexbuf_add_tri_verts(&amp;ibuf, 8, 9, 10);\nGPU_indexbuf_add_tri_verts(&amp;ibuf, 10, 9, 11);\n\nGPUIndexBuf *ibo = GPU_indexbuf_build(&amp;builder)\n</code></pre> <p>Vertex buffers contain data and attributes inside vertex buffers should match the attributes of the shader. Before a buffer can be created, the format of the buffer should be defined.</p> Create Vertex Format<pre><code>static GPUVertFormat format = {0};\nGPU_vertformat_clear(&amp;format);\nGPU_vertformat_attr_add(&amp;format, \"pos\", GPU_COMP_32, 2, GPU_FETCH_FLOAT);\n</code></pre> Create Vertex Buffer<pre><code>GPUVertBuf *vbo = GPU_vertbuf_create_with_format(&amp;format);\nGPU_vertbuf_data_alloc(vbo, 12);\n</code></pre> Fill vertex buffer with data<pre><code>for (int i = 0; i &lt; 12; i ++) {\nGPU_vertbuf_attr_set(vbo, pos.id, i, positions[i]);\n}\n</code></pre>"},{"location":"eevee_and_viewport/gpu/#batch","title":"Batch","text":"<p>Use GPUBatches to draw geometry. A GPUBatch combines the geometry with a shader and its parameters and has functions to perform a draw call. To perform a draw call the next steps should be taken.</p> <ol> <li>Construct its geometry.</li> <li>Construct a GPUBatch with the geometry.</li> <li>Attach a GPUShader to the GPUBatch with the <code>GPU_batch_set_shader</code> function or attach a built in shader using the <code>GPU_batch_program*</code> functions.</li> <li>Set the parameters of the GPUShader using the <code>GPU_batch_uniform*</code>/<code>GPU_batch_texture_bind</code> functions.</li> <li>Perform a <code>GPU_batch_draw*</code> function.</li> </ol> <p>This will draw on the geometry on the active frame buffer using the shader and the loaded parameters.</p> <p>Note</p> <p>GPUTextures can be used as render target or as input of a shader, but not inside the same drawing call.</p>"},{"location":"eevee_and_viewport/gpu/#immediate-mode-and-built-in-shaders","title":"Immediate mode and built in shaders","text":"<p>To ease development for drawing panels/UI buttons the GPU module provides an immediate mode. This is a wrapper on top of what is explained above, but in a more legacy opengl fashion.</p> <p>Blender provides builtin shaders. This is widely used to draw the user interface. A shader can be activated by calling <code>immBindBuiltinProgram</code></p> <pre><code>immBindBuiltinProgram(GPU_SHADER_2D_UNIFORM_COLOR);\n</code></pre> <p>This shader program needs a vertex buffer with a pos attribute, and a color can be set as uniform.</p> <pre><code>GPUVertFormat *format = immVertexFormat();\nuint pos = GPU_vertformat_attr_add(format, \"pos\", GPU_COMP_F32, 2, GPU_FETCH_FLOAT);\n</code></pre> <pre><code>/* Set the color attribute of the shader. */\nimmUniformColor4f(0.0f, 0.5f, 0.0f, 1.0f);\n</code></pre> <p>Fill the vertex buffer with the starting and ending position of the line to draw. <pre><code>/* Construct a line index buffer with 2 elements (start point and end point to draw) */\nimmBegin(GPU_PRIM_LINES, 2);\nimmVertex2f(pos, 0.0, 100.0);\nimmVertex2f(pos, 100.0, 0.0);\nimmEnd();\n</code></pre></p> <p>By calling <code>immEnd</code> the data drawn on the GPU.</p> <p>Note</p> <p>Use GPUBatches directly in cases where performance matters. Immediate mode buffers aren't cached, which can lead to poor performance.</p>"},{"location":"eevee_and_viewport/gpu/#tools","title":"Tools","text":"<ul> <li>Validate shaders when compiling Blender using Shader builder</li> <li>GPU debugging Renderdoc</li> </ul>"},{"location":"eevee_and_viewport/gpu/renderdoc/","title":"Renderdoc","text":"<p>Renderdoc is a widely used open source GPU debugger. Blender has several options to benefit using renderdoc for debugging.</p>"},{"location":"eevee_and_viewport/gpu/renderdoc/#frame-capturing","title":"Frame capturing","text":"<p>When Blender is compiled with <code>WITH_RENDERDOC=On</code> you can start and stop a renderdoc frame capture from within Blenders' source code.</p> <ol> <li>Add <code>GPU_debug_capture_begin</code>/<code>GPU_debug_capture_end</code> around the code you want to capture.</li> <li>Start renderdoc and launch from within renderdoc using the <code>--debug-gpu-renderdoc</code> command    line parameter</li> <li>Every time the <code>GPU_debug_capture_begin/end</code> pair is reached it will automatically record    a frame capture.</li> </ol>"},{"location":"eevee_and_viewport/gpu/renderdoc/#command-grouping","title":"Command grouping","text":"<p>With the command line parameter <code>--debug-gpu</code> blender will add meta-data to the buffers and commands. This makes it easier to navigate complex frame captures. Command grouping is automatically enabled when running with the <code>--debug-gpu-renderdoc</code> option</p>"},{"location":"eevee_and_viewport/gpu/shader_builder/","title":"ShaderBuilder","text":"<p>Using the CMAKE option <code>WITH_GPU_BUILDTIME_SHADER_BUILDER=On</code> will precompile each shader to make sure that the syntax is correct and that all the generated code compiles and links with the main shader code.</p> <p>Only shaders that are part of the <code>SHADER_CREATE_INFOS</code> and <code>.do_static_compilation(true)</code> is set, will be compiled. Enabling this option would reduce compile roundtrips when developing shaders as during compile time the shaders are validated, compiled and linked on the used platform.</p> <p>Shader builder checks against all GPU backends that can run on your system.</p>"},{"location":"eevee_and_viewport/gpu/vulkan/","title":"Vulkan backend","text":"<p>The <code>gpu</code> module has a generic API that can be used to communicate with different backends like OpenGL, Metal or Vulkan. This section describes how the Vulkan backend is structured and gives some background on specific choices made.</p>"},{"location":"eevee_and_viewport/gpu/vulkan/#vulkan-in-a-nutshell","title":"Vulkan in a nutshell","text":"<p>Note</p> <p>This is not blender specific and doesn't cover all aspects of vulkan. It is used as an introduction how vulkan is structured for people who who have some familiarity with OpenGL.</p> <p>The links in this section navigate to a Blender specific explanation.</p> <p>Compared to OpenGL index, vertex, uniform &amp; storage buffers, vulkan has only a single buffer type. How the buffer can be used in determined by a usage bitflag. In short a buffer is a chunk of memory available on the GPU.</p> <p>There are also Images. The memory that an image uses on the GPU cannot be accessed directly from the host. To change the data of an image, an intermediate buffer is needed. Reason is that images can be stored more optimal (performance wise) in GPU memory, but how is device/vendor specific. The intermediate buffer will hide differences between implementations.</p> <p>To run code on the GPU pipelines and shaders are needed.</p> <p>Note</p> <p>the term of a shader doesn't map directly between the definition that vulkan uses and the definition that Blender uses.</p> <p>The term shader in Blender maps to an OpenGL program, which is the combination of all different shader stages that are needed in a pipeline.</p> <p>In Vulkan a shader (module) is compiled GLSL code that can be used as a stage inside a pipeline.</p> <p>From now on we will use shader stage to refer to a single stage and shader to refer to the set of shader stages that work together inside a pipeline.</p> <p>There are 2 main types of pipelines. One for compute tasks and one for graphical tasks. There are other pipelines as well, but we ignore them for now as Blender doesn't use them (yet). A pipeline contains everything what needs to happen on the GPU logic-wise during a single draw or dispatch command. Dispatch commands are used to invoke compute tasks, draw commands to invoke graphical tasks.</p> <p>A pipeline has multiple shader stages. A graphics pipeline typically has a vertex and fragment stage. For each stage a shader module can be assigned. Although similar to OpenGL, the main difference is that any state change on the GPU requires a different pipeline. If you need a different blending to store the final pixel in the framebuffer, you will need another pipeline.</p> <p>The buffers and images that are needed by a pipeline are organized in descriptor sets. A descriptor set doesn't contain the buffers and images, it only references existing buffers and images.</p> <p>In vulkan a pipeline can have a small number of descriptor sets (typically up to 4). They are organized based on how likely the references needs to be updated for another reference. When a reference is changed a new descriptor set needs to be created and uploaded as the previous one can still be used by another command.</p> <p>Note</p> <p>It is possible to swap out a descriptor set for another one. For example when a specific combination of resources are often reused. In that case you might not want to recreate a descriptor set and upload it to the GPU.</p> <p>Push Constants is a small buffer (typically 128 or 256 bytes and device specific) that can be sent with an individual command. Push constants are typically used for variables in shader stages that are likely to change for each command. Push constants are faster then using a uniform buffer.</p> <p>Multiple commands are added to a command buffer and submitted in one go to the device command queue. When resources are used by multiple commands inside the command buffer synchronization needs to happen. It could be that one command is writing to a buffer, and another command reads it. Vulkan has different ways to influence the synchronization.</p> <p>Note</p> <p>It is often said that when you understand the synchronization you will understand how and why vulkan is structured in the way it is.</p> <p>Synchronization can happen between devices and queues and command buffers (semaphores and fences), between GPU and CPU (fences), between commands and between resource usages inside the same command buffer/queue (command barriers/memory barriers)</p> <p>Note</p> <p>We won't go into to detail how they work as we want to keep this section introductory. There are many great vulkan resources that explain in detail why and how these can be used.</p> <p>In blender most synchronization will be hidden for most developers/users, only when developing inside the GPU backend these concepts should be understood in more depth.</p>"},{"location":"eevee_and_viewport/gpu/vulkan/#random-topics","title":"Random topics","text":"<ul> <li>VKFrameBuffer Blender uses top left as the origin of frame buffers, Vulkan uses bottom left.</li> <li>VKVertexBuffer Vulkan only support data conversion when there are   benefits when using them. Eg saving memory bandwidth vs processing.</li> </ul>"},{"location":"eevee_and_viewport/gpu/vulkan/#naming-convention","title":"Naming convention","text":"<p>The vulkan backend has some additional naming conventions in order to clarify if a Vulkan native structure/attribute is passed along or it is from the GPU module. Reasoning is that Vulkan uses the Prefix <code>Vk</code> for their structures and Blender uses <code>VK</code> for their structures. To make the code more readable we added the next naming convention:</p> <ul> <li>Any parameter, attribute, variable that contains a Vulkan native data type must be prefixed   with <code>vk_</code>. It is not allowed to name parameters, attributes and variables that contains a   GPU module struct to start with <code>vk_</code>.</li> </ul> Naming example<pre><code>// Allowed:\nVKBuffer buffer\nVkBuffer vk_buffer\n//Not Allowed:\nVKBuffer vk_buffer\nVkBuffer buffer\n</code></pre>"},{"location":"eevee_and_viewport/gpu/vulkan/#development-tools","title":"Development tools","text":""},{"location":"eevee_and_viewport/gpu/vulkan/#build-options","title":"Build options","text":"<p>Several build options are available for development.</p> <ul> <li><code>WITH_VULKAN_BACKEND</code>: Turn this option on to compile blender with Vulkan backend.</li> <li><code>WITH_VULKAN_GUARDEDALLOC</code>: Guard driver allocated memory with guardedalloc.</li> </ul>"},{"location":"eevee_and_viewport/gpu/vulkan/#validation-layers","title":"Validation layers","text":"<ul> <li>Validation Layers</li> </ul>"},{"location":"eevee_and_viewport/gpu/vulkan/#references","title":"References","text":"<ul> <li>The vulkan backend is located in <code>source/blender/gpu/vulkan</code>.</li> <li>Platform specific parts are located in <code>intern/ghost</code>. Mainly in <code>GHOST_ContextVK.cc</code>.</li> </ul>"},{"location":"eevee_and_viewport/gpu/vulkan/buffers/","title":"Buffers","text":""},{"location":"eevee_and_viewport/gpu/vulkan/buffers/#references","title":"References","text":"<ul> <li><code>source/blender/gpu/vulkan/vk_buffer.cc</code> generic Vulkan buffer.</li> <li><code>source/blender/gpu/vulkan/vk_index_buffer.cc</code>, <code>source.blender/gpu/vulkan/vk_vertex_buffer.cc</code>, <code>source/blender/gpu/vulkan/vk_pixel_buffer.cc</code>, <code>source/blender/gpu/vulkan/vk_storage_buffer.cc</code>, <code>source/blender/gpu/vulkan/vk_uniform_buffer.cc</code> Implementation of different buffer types.</li> </ul>"},{"location":"eevee_and_viewport/gpu/vulkan/command_buffer/","title":"Command buffer","text":""},{"location":"eevee_and_viewport/gpu/vulkan/command_buffer/#resource-tracking","title":"Resource tracking","text":"<p>Submission-id</p> <ul> <li>descriptor sets and push constants uses current submission id to determine if the resources can be recycled.</li> </ul>"},{"location":"eevee_and_viewport/gpu/vulkan/command_buffer/#planned-changes","title":"Planned changes","text":"<ul> <li>Just in time encoding to add resource synchronization between individual commands that are simultaneously in flight.</li> </ul>"},{"location":"eevee_and_viewport/gpu/vulkan/pipelines/","title":"VKPipeline","text":"<p>A pipeline is a combination of different aspects that are done inside a draw call.</p>"},{"location":"eevee_and_viewport/gpu/vulkan/pipelines/#graphic-pipeline","title":"Graphic pipeline","text":""},{"location":"eevee_and_viewport/gpu/vulkan/pipelines/#compute-pipeline","title":"Compute pipeline","text":""},{"location":"eevee_and_viewport/gpu/vulkan/push_constants/","title":"Push constants","text":"<p>Push constants is a way to quickly provide a small amount of uniform data to shaders. It should be much quicker than UBOs but a huge limitation is the size of data - spec requires 128 bytes to be available for a push constant range. There are platforms that provide more data (Mesa+RDNA provides 256 bytes).</p> <p>In Blender some shader requires more data than available as push constant. As shaders can also be part of an add-on we don't have full control on the data size.</p> <p>Note</p> <p>As of February 2023 there are 50 shaders in blender that are between 128 and 256 bytes. Most of them are related to point clouds drawing. There are also 4 shaders larger than 256 bytes. They are for widget drawing and Eevee motion blur.</p> <ul> <li>Widget drawing must be migrated to use uniform buffers.</li> <li>The Eevee motion blur shaders are part of Eevee-legacy and will be replaced   with Eevee-next, that doesn't have this issue.</li> </ul>"},{"location":"eevee_and_viewport/gpu/vulkan/push_constants/#storage-types","title":"Storage types","text":"<p>Blender should be able to work even when shaders use more push constants than can fit inside the limits of the physical device. Therefore we provide 2 storage types for storing/communicating push constants with the shader.</p> <ul> <li><code>StorageType::PUSH_CONSTANTS</code>: will be selected when the push constants fits inside the limits   of the physical device.</li> <li><code>StorageType::UNIFORM_BUFFER</code>: will be selected when the push constants don't fit inside the   limits of the physical device.</li> </ul> <p>Uniform buffers can handle upto 64kb of data, but require require more memory to store the same data as it requires std140 memory layout. See below for more information about the different memory layouts.</p> <p>The selection which storage type will be used in determined in the shader interface <code>VKShaderInterface</code>.</p> <pre><code>classDiagram\n\nclass StorageType{\n  &lt;&lt;Enumeration&gt;&gt;\n    NONE\n    PUSH_CONSTANTS\n    UNIFORM_BUFFER\n}\n</code></pre>"},{"location":"eevee_and_viewport/gpu/vulkan/push_constants/#memory-layout","title":"Memory layout","text":"<p>Push constants memory layout is std430. Uniform buffers is std140. <code>vk_memory_layout.hh/cc</code> provides some utilities to modify memory based on the needed memory layout. A small overview of differences between std140 and std430:</p> <ul> <li>In std140 each element inside an array (<code>float[]</code>) are aligned at 16 bytes; in std430 they   are aligned based on the alignment the element type. In this case <code>float</code> that are aligned at   4 bytes.</li> </ul>"},{"location":"eevee_and_viewport/gpu/vulkan/vk_frame_buffer/","title":"VKFrameBuffer","text":""},{"location":"eevee_and_viewport/gpu/vulkan/vk_frame_buffer/#viewport-orientation","title":"Viewport Orientation","text":"<p>Blender uses top left as the origin of the framebuffer. Vulkan uses the bottom left. When drawing to the on-screen framebuffer each draw command is flipped. This is done by providing a negative viewport.</p> <pre><code>classDiagram\n\n    class VKFrameBuffer {\n        -bool flip_viewport_\n        +VkViewport vk_viewport_get() const\n    }\n</code></pre> <p>Framebuffers have an attribute to indicate that all draw/blit operations to this frame buffer should be flipped.</p> <p>Draw commands are automatically flipped as the <code>VkViewport</code> created for the graphics pipeline is flipped. This is done in <code>VKFrameBuffer::vk_viewport_get()</code>.</p> <p>When transferring data from framebuffer A to framebuffer B the flipping only needs to happen when <code>flip_viewport_</code> differs. When different the <code>dstOffsets</code> of the <code>VkBlitCmdImage</code> is flipped. This is done in <code>VKFrameBuffer::blit_to</code>.</p>"},{"location":"eevee_and_viewport/gpu/vulkan/vk_frame_buffer/#references","title":"References","text":"<ul> <li><code>source/blender/gpu/vulkan/vk_framebuffer.hh</code></li> <li><code>source/blender/gpu.vulkan/vk_framebuffer.cc</code></li> </ul>"},{"location":"eevee_and_viewport/gpu/vulkan/vk_vertex_buffer/","title":"Vertex Buffer","text":""},{"location":"eevee_and_viewport/gpu/vulkan/vk_vertex_buffer/#data-conversion","title":"Data conversion","text":"<p>Blender can use a <code>GPU_COMP_I32</code>/<code>GPU_COMP_U32</code> and use <code>GPU_FETCH_INT_TO_FLOAT</code> to bind it to a float attribute. Vulkan doesn't support this because it adds no benefit to the GPU.</p> <p>Note</p> <p><code>GPU_COMP_U8/I8/U16/I16</code> with <code>GPU_FETCH_INT_TO_FLOAT</code> are natively supported as they trade in a bit of work to reduce memory bandwidth.</p> <p>Although we should remove these cases in the code-base, we should still add the data conversion as add-ons might use them.</p> vk_data_conversion.hh<pre><code>bool conversion_needed(const GPUVertFormat &amp;vertex_format);\nvoid convert_in_place(void *data, const GPUVertFormat &amp;vertex_format, const uint vertex_len);\n</code></pre> <p>Based on a <code>GPUVertFormat</code> it can be checked if there are some attributes that requires conversion on the host side.</p> <p><code>convert_in_place</code> only changes the buffer (<code>data</code>) the vertex_format is still the original.</p> <p>When binding the vertex buffers to the shader the VkFormat of those attributes are also changed.</p> <p>vk_common.hh<pre><code>VkFormat to_vk_format(const GPUVertCompType type,\nconst uint32_t size,\nconst GPUVertFetchMode fetch_mode);\n</code></pre> <code>GPU_COMP_I32</code>/<code>GPU_COMP_U32</code> with <code>GPU_FETCH_INT_TO_FLOAT</code> would return a <code>VK_FORMAT_*_SFLOAT</code> as the data should already be converted to floats by calling <code>convert_in_place</code>.</p>"},{"location":"user_interface_core/","title":"User Interface","text":"<p>Dummy page.</p>"}]}